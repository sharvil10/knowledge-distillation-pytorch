# -*- coding: utf-8 -*-
"""Testing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ml1C0IYBDviMYEMFjtyO8cVIYOWRFOXC
"""

from PIL import Image
import numpy as np
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from torchvision.transforms import Normalize, ToTensor, Resize
from torchvision.models import vgg16_bn


def get_vgg():
    model = vgg16_bn(pretrained = False)
    model.avgpool = nn.AdaptiveAvgPool2d((2, 2))
    model.classifier = nn.Sequential(
                nn.Linear(512 * 2 * 2, 512),
                nn.BatchNorm1d(512),
                nn.ReLU(True),
                nn.Linear(512, 512),
                nn.BatchNorm1d(512),
                nn.ReLU(True),
                nn.Linear(512, 100),
            )
    model.to(device = 'cuda')
    model.load_state_dict(torch.load('weights_63.ckpt'))
    return model

def loss_fn(outputs, labels):
    """
    Compute the cross entropy loss given outputs and labels.

    Returns:
        loss (Variable): cross entropy loss for all images in the batch

    Note: you may use a standard loss function from http://pytorch.org/docs/master/nn.html#loss-functions. This example
          demonstrates how you can easily define a custom loss function.
    """
    return nn.CrossEntropyLoss()(outputs, labels)


def accuracy(outputs, labels):
    """
    Compute the accuracy, given the outputs and labels for all images.

    Returns: (float) accuracy in [0,1]
    """
    outputs = np.argmax(outputs, axis=1)
    return np.sum(outputs==labels)/float(labels.size)
